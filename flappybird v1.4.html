<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Flappy Bird (Canvas)</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
    }

    /* Center the game on screen */
    .wrap {
      height: 100vh;
      width: 100vw;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
    }

    /* Game keeps original aspect ratio (288x512) and fills screen height */
    canvas {
      height: 100vh;
      width: auto;
      display: block;
      image-rendering: auto;
    }

    /* If the screen is too narrow, prevent overflow by shrinking to fit width */
    @media (max-aspect-ratio: 288/512) {
      canvas {
        width: 100vw;
        height: auto;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="288" height="512"></canvas>
  </div>

<script>
(() => {
	// --- Canvas setup ---
	const W = 288, H = 512;
	const canvas = document.getElementById("game");
	const ctx = canvas.getContext("2d");

	// Prevent page scroll / zoom on mobile taps
	window.addEventListener("touchstart", (e) => e.preventDefault(), { passive: false });

	// --- Assets ---
	const IMGSRC_ASSET = (name) => `./GameObjects/${name}`;
	const IMGSRC_UI =  (name) => `./UI/${name}`;
	const images = {};
	const toLoad = {
		//game assets
		bg: IMGSRC_ASSET("background-day.png"),
		base: IMGSRC_ASSET("base.png"),
		pipe: IMGSRC_ASSET("pipe-green.png"),
		birdDown: IMGSRC_ASSET("yellowbird-downflap.png"),
		birdMid:  IMGSRC_ASSET("yellowbird-midflap.png"),
		birdUp:   IMGSRC_ASSET("yellowbird-upflap.png"),

		//UI
		ready: IMGSRC_UI("message.png"),
		gameover: IMGSRC_UI("gameover.png"),
		//scoreboard: IMGSRC_UI("scoreboard.png"),
		//medalBronze: IMGSRC_UI("medal-bronze.png"),
		//medalSilver: IMGSRC_UI("medal-silver.png"),
		//medalGold: IMGSRC_UI("medal-gold.png"),
		//medalPlat: IMGSRC_UI("medal-platinum.png"),
	};

	//PNG Numbers
	for (let i = 0; i <= 9; i++) {
		toLoad[`num${i}`] = `./UI/Numbers/${i}.png`;
	}

	function loadImage(src) {
		return new Promise((resolve, reject) => {
			const img = new Image();
			img.onload = () => resolve(img);
			img.onerror = reject;
			img.src = src;
		});
	}

	async function loadAll() {
		const entries = Object.entries(toLoad);
		for (const [k, src] of entries) {
			images[k] = await loadImage(src);
		}
	}
	
	// ------------------------ SFX ------------------------ //
	const sfx = {
		die: new Audio("./SFX/die.ogg"),
		hit: new Audio("./SFX/hit.ogg"),
		point: new Audio("./SFX/point.ogg"),
		swoosh: new Audio("./SFX/swoosh.ogg"),
		wing: new Audio("./SFX/wing.ogg"),
	};
	for (const a of Object.values(sfx)) {
		a.preload = "auto";
		a.volume = 1;
	}
	function playSfx(a) {
		try {
			a.currentTime = 0;
			a.play();
		} catch (_) {}
	}

	// --- Game constants (tuned to feel like classic Flappy Bird) ---
	const BASE_H = 112;
	const BASE_Y = H - BASE_H;

	const PIPE_W = 52;
	const PIPE_H = 320;

	const BIRD_W = 34;
	const BIRD_H = 24;

	const GRAVITY = 900;            // px/s^2
	const FLAP_VY = -310;           // px/s
	const PIPE_SPEED = 120;         // px/s (matches base scroll)
	const BG_SPEED = 30;            // px/s
	const PIPE_SPAWN_EVERY = 1.25;  // seconds
	const GAP = 100;                // opening size

	const ROT_UP = -0.45;           // radians (~-25°)
	const ROT_DOWN_MAX = 1.35;      // radians (~77°)

	// --- Game state ---
	const State = { READY: "READY", PLAY: "PLAY", HIT: "HIT", OVER: "OVER" };
	let state = State.READY;

	let hiScore = Number(localStorage.getItem("flappy_hi") || "0");

	const bird = {
		x: Math.floor(W * 0.28),
		y: Math.floor(H * 0.38),
		vy: 0,
		rot: 0,
		animT: 0,
		animI: 0,
	};
	
	const death = {
		// general timer since impact
		t: 0,

		// flash
		flashDur: 0.10,
		flashT: 0,

		// sounds
		dieDelay: 0.06,
		diePlayed: false,
		swooshPlayed: false,

		// gameover banner timing
		bannerDelay: 0.8, // 1s after impact
		bannerFadeDur: 0.35, // fade-in duration
		bannerAlpha: 0,

		// scoreboard timing (1s after banner appears => 2s after impact)
		boardDelay: 1.6,
		boardDur: 0.55,
		boardActive: false,
		boardT: 0,
		boardY: H + 150,
		boardTargetY: 230,
	};

	const bg = { x1: 0, x2: W };
	const base = { x1: 0, x2: images.base ? images.base.width : 336 }; // updated after load

	let pipes = [];
	let spawnT = 0;
	let score = 0;

	function startGame() {
		state = State.PLAY;
		bird.vy = FLAP_VY;
		bird.rot = ROT_UP;
	}

	function beginDeath() {
		if (state !== State.PLAY) return;
		
		state = State.HIT;
		
		// flash + SFX chain
		death.flashT = death.flashDur;
		playSfx(sfx.hit);
		
		death.t = 0;
		death.bannerAlpha = 0;
		death.boardActive = false;
		death.boardT = 0;
		death.boardY = H + 150;
		death.swooshPlayed = false;
		death.diePlayed = false;
		
		// show UI immediately
		// (gameover banner will be drawn when state is HIT/OVER)
		
		// Make the bird "dive"
		bird.vy = 220; // pushes it downward right away
		bird.rot = 0.6; // tilt down a bit
	}

	function flap() {
		bird.vy = FLAP_VY;
		bird.rot = ROT_UP;
		playSfx(sfx.wing);
	}

  // --- Pipes ---
  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function spawnPipePair() {
    // Top pipe y is negative (off-screen), tuned so gap stays in playable area.
    const minTop = -260;
    const maxTop = -80;
    const topY = rand(minTop, maxTop);
    const x = W + 10;

    pipes.push({
      x,
      topY,
      gap: GAP,
      scored: false,
    });
  }

  function birdRect() {
    // Slightly smaller than sprite for fair collision (like the original)
    const pad = 3;
    return {
      x: bird.x - (BIRD_W / 2) + pad,
      y: bird.y - (BIRD_H / 2) + pad,
      w: BIRD_W - pad * 2,
      h: BIRD_H - pad * 2,
    };
  }

  function rectsOverlap(a, b) {
    return (
      a.x < b.x + b.w &&
      a.x + a.w > b.x &&
      a.y < b.y + b.h &&
      a.y + a.h > b.y
    );
  }

  function checkCollisions() {
    const br = birdRect();

    // Ground collision
    if (br.y + br.h >= BASE_Y) return true;

    // Ceiling clamp (classic: you can bonk the top; we treat as collision)
    if (br.y <= 0) return true;

    // Pipes
    for (const p of pipes) {
      const topRect = { x: p.x, y: p.topY, w: PIPE_W, h: PIPE_H };
      const botY = p.topY + PIPE_H + p.gap;
      const botRect = { x: p.x, y: botY, w: PIPE_W, h: PIPE_H };

      if (rectsOverlap(br, topRect) || rectsOverlap(br, botRect)) {
        return true;
      }
    }
    return false;
  }

  // --- Input ---
  function onTap() {
    if (state === State.READY) return startGame();
    if (state === State.PLAY) return flap();
    if (state === State.OVER) return reset();
  }

  window.addEventListener("keydown", (e) => {
    if (e.code === "Space" || e.code === "ArrowUp") {
      e.preventDefault();
      onTap();
    }
  });

  canvas.addEventListener("mousedown", (e) => { e.preventDefault(); onTap(); });
  canvas.addEventListener("touchstart", (e) => { e.preventDefault(); onTap(); }, { passive: false });

	// --- Rendering helpers ---
	function drawBackground() {
		ctx.drawImage(images.bg, 0, 0);
	}

  function drawPipe(x, y, flipped) {
    if (!flipped) {
      ctx.drawImage(images.pipe, x, y);
      return;
    }
    // draw flipped vertically for top pipe
    ctx.save();
    ctx.translate(x, y + PIPE_H);
    ctx.scale(1, -1);
    ctx.drawImage(images.pipe, 0, 0);
    ctx.restore();
  }

  function drawPipes() {
    for (const p of pipes) {
      drawPipe(p.x, p.topY, true);
      const botY = p.topY + PIPE_H + p.gap;
      drawPipe(p.x, botY, false);
    }
  }

  function drawBase() {
    // Looping base (floor)
    ctx.drawImage(images.base, base.x1, BASE_Y);
    ctx.drawImage(images.base, base.x2, BASE_Y);
  }

  function drawBird() {
    const frames = [images.birdDown, images.birdMid, images.birdUp];
    const img = frames[bird.animI];

    ctx.save();
    ctx.translate(bird.x, bird.y);
    ctx.rotate(bird.rot);
    ctx.drawImage(img, -BIRD_W / 2, -BIRD_H / 2);
    ctx.restore();
  }
  
	function drawNumber(value, x, y, opts = {}) {
		const scale = opts.scale ?? 1;
		const align = opts.align ?? "center"; // "left" | "center" | "right"
		const spacing = opts.spacing ?? 0;

		const str = String(value);
		const digitImgs = [];
		let totalW = 0;
		let maxH = 0;

		for (const ch of str) {
			const d = ch.charCodeAt(0) - 48; // '0' -> 0
			const img = images[`num${d}`];
			if (!img) return; // not loaded / wrong name
			digitImgs.push(img);
			totalW += img.width * scale;
			maxH = Math.max(maxH, img.height * scale);
		}

		totalW += spacing * (digitImgs.length - 1);

		let startX = x;
		if (align === "center") startX = x - totalW / 2;
		if (align === "right")  startX = x - totalW;

		let cx = startX;
		for (const img of digitImgs) {
			ctx.drawImage(img, cx, y, img.width * scale, img.height * scale);
			cx += img.width * scale + spacing;
		}
	}

	function drawText() {
		ctx.save();
		if (state === State.READY) {
			const img = images.ready;
			const x = (W - img.width) / 2;
			const y = 10; // adjust this number to move it up/down
			ctx.drawImage(img, x, y);
		}
		if (state === State.PLAY) {
			drawNumber(score, W / 2, 40, { align: "center", scale: 1, spacing: 1 });
		}
		ctx.restore();
	}
	
	// -------------------------- Game Over -------------------------- //
	function drawFlash() {
		if (death.flashT <= 0) return;
		const a = (death.flashT / death.flashDur) * 0.9; // fade out
		ctx.save();
		ctx.globalAlpha = a;
		ctx.fillStyle = "#fff";
		ctx.fillRect(0, 0, W, H);
		ctx.restore();
	}
	function drawGameOverBanner() {
		if (!images.gameover) return;
		if (death.bannerAlpha <= 0) return;

		const x = (W - images.gameover.width) / 2;
		const y = 170; // adjust as needed
		
		ctx.save();
		ctx.globalAlpha = death.bannerAlpha;
		ctx.drawImage(images.gameover, x, y);
		ctx.restore();
	}
	function getMedalKey() {
		// Classic-ish thresholds (tweak as you want)
		if (score >= 40) return "medalPlat";
		if (score >= 30) return "medalGold";
		if (score >= 20) return "medalSilver";
		if (score >= 10) return "medalBronze";
		return null;
	}
	function drawScoreboard() {
		if (!death.boardActive) return;

		const panelW = images.scoreboard ? images.scoreboard.width : 238;
		const panelH = images.scoreboard ? images.scoreboard.height : 126;

		const x = (W - panelW) / 2;
		const y = death.boardY;

		// panel
		if (images.scoreboard) {
			ctx.drawImage(images.scoreboard, x, y);
		}
		else {
			// fallback simple panel if you don't have scoreboard.png
			ctx.save();
			ctx.fillStyle = "rgba(255,255,255,0.95)";
			ctx.strokeStyle = "rgba(0,0,0,0.35)";
			ctx.lineWidth = 2;
			roundRect(ctx, x, y, panelW, panelH, 8);
			ctx.fill();
			ctx.stroke();
			ctx.restore();

			ctx.save();
			ctx.fillStyle = "#333";
			ctx.font = "bold 15px Arial";
			ctx.textAlign = "right";
			ctx.fillText("SCORE", x + panelW - 22, y + 28);
			ctx.fillText("BEST",  x + panelW - 22, y + 80);
			ctx.restore();
		}

		// medal
		const medalKey = getMedalKey();
		const medalImg = medalKey ? images[medalKey] : null;

		if (medalImg) {
			ctx.drawImage(medalImg, x + 30, y + 44, medalImg.width, medalImg.height);
		}
		else {
			// fallback medal placeholder (only if you don't have medal sprites)
			ctx.save();
			ctx.globalAlpha = 0.35;
			ctx.beginPath();
			ctx.arc(x + 52, y + 68, 18, 0, Math.PI * 2);
			ctx.fillStyle = "#c9a227";
			ctx.fill();
			ctx.restore();
		}
		// numbers (your PNG digits)
		// right side positions tuned for a 238x126 panel
		drawNumber(score, x + panelW - 24, y + 35, { align: "right", scale: 0.7, spacing: 1 });
		drawNumber(hiScore, x + panelW - 24, y + 85, { align: "right", scale: 0.7, spacing: 1 });
	}

	function roundRect(ctx, x, y, w, h, r) {
		const rr = Math.min(r, w / 2, h / 2);
		ctx.beginPath();
		ctx.moveTo(x + rr, y);
		ctx.arcTo(x + w, y, x + w, y + h, rr);
		ctx.arcTo(x + w, y + h, x, y + h, rr);
		ctx.arcTo(x, y + h, x, y, rr);
		ctx.arcTo(x, y, x + w, y, rr);
		ctx.closePath();
	}

	// --- Update loop ---
	let lastT = 0;

	function update(dt) {
		// Animate bird flapping (even on READY)
		bird.animT += dt;
		const animSpeed = (state === State.PLAY) ? 0.09 : 0.14;
		if (bird.animT >= animSpeed) {
			bird.animT = 0;
			bird.animI = (bird.animI + 1) % 3;
		}

		if (state === State.READY) {
			// Gentle idle bob (classic feel)
			bird.y = Math.floor(H * 0.38) + Math.sin(perfNow() / 250) * 5;
			bird.rot = Math.sin(perfNow() / 400) * 0.05;
			return;
		}
		
		// ---------- Game Over
		if (state === State.HIT || state === State.OVER) {
			
			death.t += dt;
			
			bird.vy += GRAVITY * dt;
			bird.y += bird.vy * dt;

			// rotate downward while falling
			bird.rot = Math.min(1.35, bird.rot + 2.8 * dt);
			
			// flash countdown
			if (death.flashT > 0) death.flashT = Math.max(0, death.flashT - dt);
			
			// play die shortly after hit
			if (!death.diePlayed && death.t >= death.dieDelay) {
				death.diePlayed = true;
				playSfx(sfx.die);
			}

			// gameover banner fade-in after 1s
			if (death.t >= death.bannerDelay) {
				// play swoosh exactly when banner starts appearing
				if (!death.swooshPlayed) {
					death.swooshPlayed = true;
					playSfx(sfx.swoosh);
				}
				const p = (death.t - death.bannerDelay) / death.bannerFadeDur;
				death.bannerAlpha = Math.max(0, Math.min(1, p));
			} 
			else {
				death.bannerAlpha = 0;
			}

			// Start scoreboard after 2s delay
			if (!death.boardActive) {
				death.boardT += dt;
				if (death.boardT >= death.boardDelay) {
					death.boardActive = true;
					death.boardT = 0;
				}
			}
			else {
				// animate board from below to target
				death.boardT = Math.min(death.boardDur, death.boardT + dt);
				const t = death.boardT / death.boardDur;
				// easeOutCubic
				const e = 1 - Math.pow(1 - t, 3);
				const startY = H + 150;
				death.boardY = startY + (death.boardTargetY - startY) * e;
			}

			// ground clamp and finalize OVER
			const groundY = BASE_Y - BIRD_H / 2 + 2;
			if (bird.y >= groundY) {
				bird.y = groundY;
				bird.vy = 0;
				bird.rot = 1.35;

				if (state === State.HIT) {
					state = State.OVER;
					if (score > hiScore) {
						hiScore = score;
						localStorage.setItem("flappy_hi", String(hiScore));
					}
				}
			}
			return; // important: stop normal PLAY updates
		}

		// Base scroll
		base.x1 -= PIPE_SPEED * dt;
		base.x2 -= PIPE_SPEED * dt;
		const baseW = images.base.width; // 336
		if (base.x1 <= -baseW) base.x1 = base.x2 + baseW;
		if (base.x2 <= -baseW) base.x2 = base.x1 + baseW;

		// Bird physics
		bird.vy += GRAVITY * dt;
		bird.y += bird.vy * dt;

		// Rotation based on velocity
		const t = Math.min(1, Math.max(0, (bird.vy + 250) / 650));
		bird.rot = ROT_UP * (1 - t) + ROT_DOWN_MAX * t;

		// Pipes
		spawnT += dt;
		if (spawnT >= PIPE_SPAWN_EVERY) {
			spawnT = 0;
			spawnPipePair();
		}
		for (const p of pipes) {
			p.x -= PIPE_SPEED * dt;
			// Score when passed
			if (!p.scored && (p.x + PIPE_W) < (bird.x - BIRD_W / 2)) {
				p.scored = true;
				score++;
				playSfx(sfx.point);
			}
		}

		// Remove offscreen pipes
		pipes = pipes.filter(p => p.x > -PIPE_W - 10);

		// Collisions
		if (checkCollisions()) {
			beginDeath();
		}
	}

	function render() {
		ctx.clearRect(0, 0, W, H);
		drawBackground();
		drawPipes();
		drawBase();
		drawBird();
		drawText();
		
		if (state === State.HIT || state === State.OVER) {
			drawGameOverBanner();
			drawScoreboard();
			drawFlash();
		}
	}

	function perfNow() {
		return (performance && performance.now) ? performance.now() : Date.now();
	}
  
	function reset() {
		state = State.READY;
		bird.y = Math.floor(H * 0.38);
		bird.vy = 0;
		bird.rot = 0;
		bird.animT = 0;
		bird.animI = 0;

		death.t = 0;
		death.flashT = 0;
		death.diePlayed = false;
		death.swooshPlayed = false;
		death.bannerAlpha = 0;
		death.boardActive = false;
		death.boardT = 0;
		death.boardY = H + 150;

		bg.x1 = 0; bg.x2 = W;

		base.x1 = 0;
		base.x2 = 336;

		pipes = [];
		spawnT = 0;
		score = 0;
	}

	function loop(t) {
		const now = t || perfNow();
		const dt = Math.min(0.033, (now - lastT) / 1000) || 0; // cap delta for stability
		lastT = now;

		update(dt);
		render();
		requestAnimationFrame(loop);
	}

	// --- Boot ---
	loadAll().then(() => {
		// initialize base second image x using actual width
		base.x1 = 0;
		base.x2 = images.base.width;
		reset();
		requestAnimationFrame(loop);
	})
	.catch((err) => {
		console.error(err);
		ctx.fillStyle = "#fff";
		ctx.font = "16px Arial";
		ctx.fillText("Failed to load assets. Check /GameObjects paths.", 10, 30);
	});
})();
</script>
</body>
</html>